[INTRODUCTION]:
This document defines an alternative Fibonacci-based methodology for planning complex implementation projects through organic growth. Start with single vision statement, expand following Fibonacci sequence for natural complexity scaling, then transition to checkpoint insertion pattern. Every step must be tangible, measurable, and executable. No ambiguity permitted.

[WRITING STYLE/TONE/VOICE]:
Assertive. Deterministic. Direct. Pragmatic. Hands-on. Zero fluff. Commands not suggestions. Facts not opinions. Concrete not abstract. Executable not theoretical. Present tense imperative. No optional elements. No maybe. No perhaps. Only MUST and MUST NOT.

[GUIDANCE FOR AI AGENT]:
Follow this process sequentially. Do not skip phases. Fibonacci expansion creates organic complexity growth mirroring natural problem decomposition. After reaching 34 steps, switch to checkpoint insertion pattern. Maintain all previous steps when expanding. Use STEP_XX numbering for final itemization. Validation steps specify exact test files with atomic test definitions. Apply TDD cycle to every validation: write test, fail, implement, pass, refactor, pass. One test equals one validation. Maximum three dash items per checkpoint unless fourth is TDD cycle guidance. Plain text with dashes only. No backticks. No code blocks in steps.

[SYNTAX]:
Phase separator: <--- TRUST THE PROCESS --->
Step format implementation: STEP_XX: Brief imperative description
Step format validation: STEP_XX: Brief validation description
Validation structure:
- Create tests/category/test-name.sh with fixtures if needed
- Tests: atomic test list, comma-separated
- All tests atomic: 1 test = 1 validation
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

[PATTERNS]:
Start minimal, grow organically following Fibonacci. Each expansion adds previous two step counts worth of detail. Early phases grow slowly, middle phases accelerate. After 34 steps, switch to checkpoint insertion. Fibonacci creates natural information density progression. Later phases focus on validation and quality gates rather than feature expansion.

[ANTIPATTERNS]:
Never use letters for step numbering in final output. Never exceed three dash items except for TDD guidance. Never write code in process steps. Never use examples with specific values unless from contract. Never create validation without specifying test file path. Never forget TDD cycle guidance. Never use magic numbers in validation criteria. Never force Fibonacci when checkpoints make more sense.

[PHASE BREAKER]: "<--- TRUST THE PROCESS --->"

-----

@___01_single_step___[ONE STEP STAPPENPLAN]:
Begin with single comprehensive vision statement. This statement captures entire project scope in one paragraph. Statement must be specific enough to guide all subsequent decomposition while broad enough to encompass full implementation. This is executive summary level. Answer: What is being built and why does it matter?

<--- TRUST THE PROCESS ----->

@___02_sequential_steps___[TWO STEPS STAPPENPLAN]:
Split the single vision into two fundamental phases: preparation and execution. Or: design and implementation. Or: foundation and superstructure. Whatever dichotomy best serves the project. These two steps represent the highest-level work breakdown. Each step is still quite abstract but shows major dependency. Step one must complete before step two begins.

<--- TRUST THE PROCESS ----->

@___03_sequential_steps___[THREE STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (1 + 2 = 3). Take the two steps and expand by adding one new intermediate or follow-up step. Common patterns: beginning, middle, end. Or: setup, core work, teardown. Or: build, test, deploy. Three steps show minimal viable progression through project lifecycle. Steps remain high-level but show sequence.

<--- TRUST THE PROCESS ----->

@___05_sequential_steps___[FIVE STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (2 + 3 = 5). Take the three steps and add two more steps by splitting most complex step or adding critical dependencies. Five steps typically map to major capability domains. Each step represents substantial deliverable or milestone. Five steps provide program management visibility into major work streams. Descriptions specify domain but not implementation details.

<--- TRUST THE PROCESS ----->

@___08_sequential_steps___[EIGHT STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (3 + 5 = 8). Take the five steps and add three more steps through strategic splits or dependency additions. Eight steps show project rhythm. Natural checkpoints emerge. Each step now represents focused work package. Eight steps provide technical leadership visibility into execution sequence. Descriptions hint at deliverables and artifacts.

<--- TRUST THE PROCESS ----->

@___13_sequential_steps___[THIRTEEN STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (5 + 8 = 13). Take the eight steps and add five more steps by splitting complex steps or revealing hidden dependencies. Thirteen steps show detailed execution path. Dependencies between steps become critical. Each step is actionable work item. Thirteen steps provide senior implementer visibility. Descriptions specify what gets built or configured.

<--- TRUST THE PROCESS ----->

@___21_sequential_steps___[TWENTY-ONE STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (8 + 13 = 21). Take the thirteen steps and add eight more steps by breaking down complex activities and exposing all major dependencies. Twenty-one steps show comprehensive implementation plan. Each step is discrete task. Dependencies form critical path. Twenty-one steps provide implementer-level granularity. Descriptions specify exact artifacts, commands, or configurations.

<--- TRUST THE PROCESS ----->

@___34_sequential_steps___[THIRTY-FOUR STEPS STAPPENPLAN]:
Fibonacci expansion: previous two step counts (13 + 21 = 34). Take the twenty-one steps and add thirteen more steps by splitting remaining complex steps into atomic actions. Thirty-four steps represent fully decomposed implementation plan. Each step is single-purpose action. No step requires further decomposition to execute. Thirty-four steps provide complete implementation visibility. This is final Fibonacci expansion before quality gates insertion.

<--- TRUST THE PROCESS ----->

@___36_sequential_steps___[THIRTY-SIX STEPS PLUS TWO INITIAL VALIDATIONS]:
Keep all thirty-four implementation steps. Add two validation checkpoint steps at early critical junctions: one after foundational setup, one after configuration complete. These first checkpoints validate project can proceed to complex implementation. Checkpoints define specific test files to create, list atomic tests to execute, reiterate one-test-one-validation principle, include TDD cycle guidance. Total: thirty-four implementation plus two validation equals thirty-six steps.

<--- TRUST THE PROCESS ----->

@___42_sequential_steps___[THIRTY-SIX STEPS PLUS SIX TOTAL VALIDATIONS]:
Keep all thirty-four implementation steps and two existing validations. Add four more validation checkpoint steps at strategic boundaries: after CI pipeline, after integrity system, after release automation, after publishing system. Six checkpoints total now validate: foundation, configuration, CI, integrity, release, publishing. Each checkpoint validates cumulative work in its domain. Total: thirty-four implementation plus six validation equals forty steps, round to forty-two to maintain progression.

<--- TRUST THE PROCESS ----->

@___48_sequential_steps___[THIRTY-SIX IMPLEMENTATION PLUS TWELVE VALIDATIONS]:
Keep all thirty-four implementation steps. Expand to thirty-six implementation steps by splitting two most critical steps. Split six checkpoints into twelve focused validation steps: each checkpoint becomes two validations testing core functionality and edge cases separately. Renumber everything sequentially as STEP_01 through STEP_48. Validation format matches previous phases. Total: thirty-six implementation plus twelve validation equals forty-eight steps.

<--- TRUST THE PROCESS ----->

@___52_sequential_steps___[FORTY-EIGHT STEPS PLUS FOUR GATEWAYS]:
Keep all forty-eight steps from previous phase. Insert four release gateway steps at major milestone boundaries: after foundation completion (GATEWAY_01), after validation infrastructure complete (GATEWAY_02), after core system functional (GATEWAY_03), after all validations pass (GATEWAY_04). Gateways aggregate multiple checkpoint results and add integration tests. Gateways block progression until prerequisites pass. Total: forty-eight steps plus four gateways equals fifty-two steps.

<--- TRUST THE PROCESS ----->

@___56_sequential_steps___[FORTY-EIGHT STEPS PLUS EIGHT GATEWAYS]:
Keep all forty-eight steps. Split four gateways into eight sub-gateways: automated verification gateway and manual review gateway for each milestone. Automated gateways run deterministic tests. Manual gateways require human sign-off on: documentation completeness, architecture review, security audit, performance benchmarks. Each manual gateway specifies exact review checklist. Total: forty-eight steps plus eight gateways equals fifty-six steps. Renumber gateways as GATEWAY_01 through GATEWAY_08.

-----

[FIBONACCI RATIONALE]

Why Fibonacci progression:
- Mirrors natural problem complexity growth
- Early steps stay abstract longer (1, 2, 3, 5)
- Middle steps show acceleration (8, 13, 21)
- Final step reaches comprehensive detail (34)
- Prevents premature over-specification
- Allows organic discovery of hidden complexity
- Each expansion builds on sum of previous two expansions
- Creates natural information density gradient

When to use Fibonacci vs doubling:
- Use Fibonacci when problem complexity not fully understood at start
- Use doubling when problem well-defined and systematic decomposition possible
- Fibonacci better for exploratory or research-heavy projects
- Doubling better for production implementations of known patterns

Transition point (34 → 36 → 42 → 48):
- After 34 steps, feature set complete
- Remaining expansions add quality gates, not features
- Validation and release management follow different scaling logic
- Checkpoint counts (2, 6, 12) follow triangular pattern
- Gateway counts (4, 8) follow doubling pattern

-----

[END PROCESS DEFINITION]
