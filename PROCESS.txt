[INTRODUCTION]:
This document defines the deterministic methodology for planning complex implementation projects through iterative refinement. Start with high-level vision, progressively decompose into atomic executable steps, inject validation checkpoints at strategic intervals, and culminate with release gateways. Every step must be tangible, measurable, and executable. No ambiguity permitted.

[WRITING STYLE/TONE/VOICE]:
Assertive. Deterministic. Direct. Pragmatic. Hands-on. Zero fluff. Commands not suggestions. Facts not opinions. Concrete not abstract. Executable not theoretical. Present tense imperative. No optional elements. No maybe. No perhaps. Only MUST and MUST NOT.

[GUIDANCE FOR AI AGENT]:
Follow this process sequentially. Do not skip phases. Each refinement doubles complexity or adds validation. Maintain all previous steps when expanding. Use STEP_XX numbering for final itemization. Validation steps specify exact test files with atomic test definitions. Apply TDD cycle to every validation: write test, fail, implement, pass, refactor, pass. One test equals one validation. Maximum three dash items per checkpoint unless fourth is TDD cycle guidance. Plain text with dashes only. No backticks. No code blocks in steps.

[SYNTAX]:
Phase separator: <--- TRUST THE PROCESS --->
Step format implementation: STEP_XX: Brief imperative description
Step format validation: STEP_XX: Brief validation description
Validation structure:
- Create tests/category/test-name.sh with fixtures if needed
- Tests: atomic test list, comma-separated
- All tests atomic: 1 test = 1 validation
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

[PATTERNS]:
Start vague, end precise. Six becomes twelve becomes twenty-four. Identify complex steps, split them. Insert checkpoints after logical completion points. Every sixth final step gets validation. Validation steps are not implementation steps. Keep ratios: implementation to validation approximately 3:1. Checkpoints validate cumulative work, not single steps. Group validations by domain: structure, configuration, CI, integrity, release, publishing.

[ANTIPATTERNS]:
Never use letters for step numbering in final output. Never exceed three dash items except for TDD guidance. Never write code in process steps. Never use examples with specific values unless from contract. Never batch multiple implementations into one step at final level. Never create validation without specifying test file path. Never forget TDD cycle guidance. Never use magic numbers in validation criteria. Never reference tools that don't exist yet.

[PHASE BREAKER]: "<--- TRUST THE PROCESS --->"

-----

@___06_sequential_steps___[SIX STEPS STAPPENPLAN]:
Begin with six high-level phases that map the entire journey from initial setup to final delivery. Each phase represents a major capability milestone. Phases must be sequential and build upon each other. No phase can start before its predecessor completes. These six phases provide executive-level visibility into project structure without implementation details. Use simple present tense descriptions focusing on outcomes not methods.

<--- TRUST THE PROCESS ----->

@___12_sequential_steps___[TWELVE INFERED STEPS STAPPENPLAN]:
Take each of the six phases and decompose into two logical sub-phases, yielding twelve steps total. Each split reveals one preparatory step and one execution step, or one design step and one implementation step. Maintain sequential dependency chain. These twelve steps provide mid-level management visibility showing how each major phase breaks down into actionable chunks. Descriptions remain outcome-focused but hint at method.

<--- TRUST THE PROCESS ----->

@___24_sequential_steps___[TWENTY FOUR INFERED STEPS STAPPENPLAN]:
Take each of the twelve steps and split into two granular steps, yielding twenty-four steps total. Some splits separate planning from execution. Others separate component A from component B. Others separate write from test. Each step now represents a distinct deliverable or artifact. These twenty-four steps provide technical lead visibility into implementation sequence. Descriptions must be specific about what gets created or configured.

<--- TRUST THE PROCESS ----->

@___36_sequential_steps___[THIRTY SIX SAME 24 + 12-COMPLEX-ONLY-SET INFERED STEPS STAPPENPLAN]:
Keep all twenty-four steps. Identify the twelve most complex steps based on: multiple sub-concerns, high cognitive load, error-prone nature, or critical path position. Split each of these twelve complex steps into two sub-steps using a/b notation initially or direct expansion. Result: twelve simple steps remain as-is, twelve complex steps become twenty-four detailed steps, total equals thirty-six steps. These thirty-six steps provide implementer visibility into every discrete action required. Descriptions specify exact artifacts, commands, or configurations.

<--- TRUST THE PROCESS ----->

@___42_sequential_steps___[EACH SIX CHECKPOINTS STAPPENPLAN]:
Keep all thirty-six implementation steps. Insert six validation checkpoint steps at strategic completion boundaries: after directory structure, after configuration, after CI pipeline, after integrity system, after release automation, after publishing system. Each checkpoint defines specific test files to create, lists atomic tests to execute, reiterates one-test-one-validation principle, and includes TDD cycle guidance as fourth dash. Checkpoints validate cumulative implementation, not individual steps. Position checkpoints where failure would invalidate subsequent work. Total: thirty-six implementation plus six validation equals forty-two steps.

<--- TRUST THE PROCESS ----->

@___48_sequential_steps___[EACH THREE INFERED CHECKPOINTS STAPPENPLAN]:
Keep all thirty-six implementation steps. Split each of six checkpoints into two focused validation steps, yielding twelve validation steps total. First validation in each pair tests core functionality, second tests edge cases or integration. For example: directory structure splits into base directories validation and category directories validation. Configuration splits into limits validation and naming rules validation. CI splits into reject-invalid validation and accept-valid validation. Integrity splits into hash generation and tree determinism. Release splits into changelog and versioning. Publishing splits into upload and compliance. Total: thirty-six implementation plus twelve validation equals forty-eight steps. Renumber all steps sequentially as STEP_01 through STEP_48.

<--- TRUST THE PROCESS ----->

@___52_sequential_steps___[EACH FOUR RELEASE GATEWAY STAPPENPLAN]:
Keep all forty-eight steps from previous phase. Insert four release gateway steps at major milestone boundaries: after STEP_10 as GATEWAY_01 verifying foundation readiness, after STEP_21 as GATEWAY_02 verifying validation infrastructure readiness, after STEP_31 as GATEWAY_03 verifying core system readiness, after STEP_48 as GATEWAY_04 verifying production readiness. Each gateway aggregates multiple checkpoint results and adds integration smoke tests. Gateway format matches checkpoint format but tests span multiple domains. Gateways block progression until all prerequisites pass. Total: forty-eight steps plus four gateways equals fifty-two steps.

<--- TRUST THE PROCESS ----->

@___56_sequential_steps___[EACH FOUR FINAL RELEASE GATEWAY STAPPENPLAN]:
Keep all forty-eight steps and four gateways from previous phase. Split each of four gateways into two sub-gateways: automated verification gateway and manual review gateway. Automated gateway runs deterministic tests. Manual gateway requires human sign-off on non-deterministic criteria: documentation completeness, architecture review, security audit, performance benchmarks. Each manual gateway specifies exact review checklist. Total: forty-eight steps plus eight gateways equals fifty-six steps. Renumber gateways as GATEWAY_01 through GATEWAY_08. Final sequence: STEP_01, STEP_02, ..., GATEWAY_01, GATEWAY_02, ..., STEP_XX, ..., GATEWAY_07, GATEWAY_08, STEP_48.

-----

[END PROCESS DEFINITION]
