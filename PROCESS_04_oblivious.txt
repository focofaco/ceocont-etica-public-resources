[INTRODUCTION]:
This document defines a methodology with density-based checkpoint and gateway insertion. Action steps grow, then checkpoints are inserted based on execution step density, finally gateways based on density. Every step must be tangible, measurable, and executable. No ambiguity permitted.

[WRITING STYLE/TONE/VOICE]:
Assertive. Deterministic. Direct. Pragmatic. Hands-on. Zero fluff. Commands not suggestions. Facts not opinions. Concrete not abstract. Executable not theoretical. Present tense imperative. No optional elements. No maybe. No perhaps. Only MUST and MUST NOT.

[GUIDANCE FOR AI AGENT - INTERACTIVE EXECUTION]:
This is an interactive execution guide. When user says "next phase" or "proceed":
1. Read IMPLEMENTATION-PLAN.md completely
2. Count total STEP_XX entries present
3. Find the section below that starts with @___[your_current_count]_
4. Read ONLY that section - do NOT read ahead to sections you haven't reached
5. Execute that section's instructions
6. Add results below last "<--- TRUST THE PROCESS --->" separator in IMPLEMENTATION-PLAN.md
7. Commit and push
8. The process continues until you reach a section that says "This is the final compact process"

Formula interpretation:
- [INIT]: Initial step creation, starting point for a new type
- [MITOSE]: Growth through replication and expansion
- Formula notation shows composition and relationships between step types
- Density formulas: checkpoint_count = execution_steps / checkpoint_interval, gateway_count = execution_steps / gateway_interval

Density-based expansion mechanics:
- Execution steps expand until reaching fixed count, then stop
- Checkpoint count calculated from execution step density: exec_steps / interval
- Gateway count calculated from execution step density: exec_steps / interval
- Density increases through interval reduction: larger interval → fewer items, smaller interval → more items
- All density calculations reference fixed execution step count, never total accumulated steps
- Renumber sequentially after each phase: STEP_01, STEP_02, STEP_03, etc.
- Preserve step content during renumbering, only update numbers

Step formatting rules:
- Implementation steps: STEP_XX: Brief imperative description
- Validation steps: STEP_XX: Brief validation description
- Checkpoint format: exactly three dash items plus optional fourth for TDD cycle
- Gateway format: similar to checkpoint but spans multiple domains
- Use plain text with dashes only, never use backticks or code blocks

Validation requirements:
- Every validation MUST specify exact test file path: tests/category/test-name.sh
- List atomic tests as comma-separated items
- One test equals one validation - never bundle multiple validations
- Always include TDD cycle guidance as fourth dash item
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

Density calculation strategy:
- Checkpoint density phase 1: larger interval, lower density, fewer checkpoints
- Checkpoint density phase 2: smaller interval, higher density, more checkpoints (typically double from phase 1)
- Gateway density phase 1: larger interval, lower density, fewer gateways
- Gateway density phase 2: smaller interval, higher density, more gateways (typically double from phase 1)
- Ratio tracking: maintain awareness of execution:validation:gateway ratios
- Example: 8 exec : 4 checkpoints : 2 gateways = 2:1:0.25 ratio

[RUNTIME CHECKPOINT POLICY]:
Objective: Define checkpoint creation policy during execution sequence of implementation steps and gateways.

Step counting:
- Counting is 1-based: step 1, step 2, step 3, …
- Each execution of implementation step or gateway increments count by +1
- Checkpoint occurs at end of designated step, after successful execution
- Single unified counter: implementation steps and gateways both increment same counter

Phase 1 - Initial checkpoint after 4 steps:
- Rule: execute 4 steps without checkpoint, create checkpoint at end of 5th step
- Formula: if current_step = 5 → create checkpoint
- Usage: this initial phase applies only once at beginning of execution flow
- Rationale: larger initial window reduces checkpoint overhead when flow is still stable

Phase 2 - Checkpoints every 2 steps:
- After first checkpoint from Phase 1, pattern changes
- Rule: create checkpoint whenever 2 steps have executed since last checkpoint
- Equivalently: every interval of 2 steps, next step creates new checkpoint
- Formula:
  • Let k = step number where last checkpoint occurred
  • Next checkpoint must occur at step k + 3
  • After that, new k becomes this step number, repeat rule
- Practical interpretation: between one checkpoint and next, exactly 2 "pure" execution steps exist
- Sequence pattern: exec → exec → checkpoint → exec → exec → checkpoint → …
- Rationale: smaller window increases safety in critical or long execution phases

Timeline example (implementation steps):
Legend: E = normal execution step, C = execution with checkpoint creation at end

Step:   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
Action: E  E  E  E  C  E  E  C  E  E  C  E  E  C  E

Explanation:
- Steps 1–4: 4 executions without checkpoint (Phase 1)
- Step 5: execution + checkpoint (first checkpoint, ends Phase 1)
- Steps 6–7: 2 "pure" executions after checkpoint
- Step 8: execution + checkpoint
- Steps 9–10: 2 "pure" executions after checkpoint
- Step 11: execution + checkpoint
- Steps 12–13: 2 "pure" executions after checkpoint
- Step 14: execution + checkpoint
- Pattern continues indefinitely

Application to gateways:
- Gateways follow same counting and checkpoint policy as implementation steps
- Each gateway passage counts as 1 execution step
- Step counter does NOT differentiate between implementation step and gateway
- Implementation step or gateway both increment by +1
- Checkpoints occur at same step indices (5, 8, 11, 14, …) regardless of element type

Mixed example (implementation steps + gateways):
Step:      1    2      3  4    5      6  7    8
Element:   step step   gw step step   gw step step
Type:      E    E      E  E    C      E  E    C

- Steps 1–4: any combination of implementation steps/gateways, no checkpoint
- Step 5: element (implementation step or gateway) executes and creates checkpoint
- After: maintains "2 executions between checkpoints" rule

Operational summary:
- Initialize step_counter = 0
- At each execution of implementation step or gateway:
  1) step_counter ← step_counter + 1
  2) if step_counter = 5 → create checkpoint (end Phase 1)
  3) after first checkpoint:
     - maintain last_checkpoint = step where checkpoint occurred
     - if step_counter = last_checkpoint + 3 → create new checkpoint
     - update last_checkpoint ← step_counter

MUST follow this policy. No exceptions. No deviations. Deterministic checkpoint creation ensures consistent recovery points throughout execution flow.

[SYNTAX]:
Phase separator: <--- TRUST THE PROCESS --->
Step format implementation: STEP_XX: Brief imperative description
Step format validation: STEP_XX: Brief validation description
Validation structure:
- Create tests/category/test-name.sh with fixtures if needed
- Tests: atomic test list, comma-separated
- All tests atomic: 1 test = 1 validation
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

[PATTERNS]:
Start minimal, expand rapidly to fixed execution steps. Minimal action set forces high-level thinking. After execution steps complete, calculate checkpoint density from those execution steps. After checkpoint expansion complete, calculate gateway density from those same execution steps. All density calculations based on fixed execution steps, not on total accumulated count. Density increases with each expansion.

Phase progression patterns:
- Execution expansion: rapid growth to fixed count, focus on essential actions only
- Checkpoint insertion: density-driven, calculated from fixed execution count
- Gateway insertion: density-driven, calculated from fixed execution count
- Fixed baseline: execution steps remain constant once reached, only validation/gateway density changes
- Compact design: minimal execution steps forces maximum abstraction and essential-only thinking

Density calculation patterns:
- Always reference fixed execution step count as denominator
- Never use total accumulated steps (exec + validation + gateway) in density formulas
- Checkpoint interval reduction increases checkpoint density
- Gateway interval reduction increases gateway density
- Track ratios: exec:checkpoint:gateway ratios reveal process balance
- Example progression: 8:2:1 → 8:4:1 → 8:4:2 (execution fixed, validations/gateways increase)

Step description patterns:
- Execution steps must be high-level and essential: forced by minimal count constraint
- Use imperative mood: "Create", "Configure", "Implement", "Deploy"
- Be specific about major capabilities: "Implement integrity verification system" not "Add checks"
- Each execution step represents substantial capability or infrastructure component
- Validation steps verify cumulative implementation across execution steps
- Gateway steps aggregate multiple checkpoint results plus integration tests

Validation placement patterns:
- Checkpoint positioning based on density calculation, not arbitrary choice
- Higher checkpoint density (smaller interval) provides more granular validation
- Distribute checkpoints evenly across execution step sequence
- Each checkpoint validates subset of execution steps within its coverage interval
- Gateways placed at major milestones spanning multiple checkpoint domains

Quality patterns with density focus:
- Minimal execution count demands maximum clarity and essential-only scope
- High validation density compensates for minimal execution granularity
- Density ratios reveal validation coverage: 2:1 ratio means 1 checkpoint per 2 exec steps
- Gateway density creates staged release path even with compact execution plan
- Fixed execution baseline ensures consistent density reference point

[ANTIPATTERNS]:
Never use letters for step numbering in final output. Never exceed three dash items except for TDD guidance. Never write code in process steps. Never use examples with specific values unless from contract. Never create validation without specifying test file path. Never forget TDD cycle guidance. Never use magic numbers in validation criteria. Never calculate density based on total steps instead of execution steps.

Density calculation antipatterns:
- Never use total step count (exec + validation + gateway) in density formulas
- Never calculate checkpoint density from checkpoint count instead of execution count
- Never calculate gateway density from gateway count instead of execution count
- Never change execution step count after fixing it for density reference
- Never confuse interval (denominator) with count (result)
- Never apply density formulas to early phases before execution steps are fixed
- Never forget that density = count / interval, not interval / count

Numbering and formatting antipatterns:
- Never skip renumbering after inserting checkpoints or gateways
- Never use non-sequential numbering
- Never lose track of total step count during density-based insertion
- Never forget to update STEP_XX numbers when inserting validations between executions
- Never use inconsistent numbering schemes within same plan

Execution step antipatterns:
- Never create more execution steps after reaching fixed count
- Never reduce execution step count during checkpoint or gateway phases
- Never split execution steps during validation phases
- Never create low-level execution steps - keep them high-level and essential
- Never include implementation details in execution step descriptions
- Never create execution steps for trivial operations

Checkpoint antipatterns:
- Never position checkpoints arbitrarily - follow density calculation
- Never create uneven checkpoint distribution across execution sequence
- Never validate steps not yet implemented or outside checkpoint's interval coverage
- Never bundle multiple unrelated tests in single checkpoint
- Never forget exact test file path specification
- Never omit TDD cycle guidance from checkpoint dash items

Gateway antipatterns:
- Never create gateways before checkpoint insertion complete
- Never design gateways that only test single domain - gateways must span multiple
- Never omit integration tests from gateways
- Never forget manual review criteria for gateways
- Never position gateways within phases instead of at milestone boundaries
- Never create gateway density from wrong baseline

Expansion antipatterns:
- Never lose previous steps when inserting checkpoints or gateways
- Never change content of existing steps during renumbering
- Never skip density calculation phases
- Never read ahead to future phases before reaching them
- Never mix execution expansion with checkpoint insertion in same phase
- Never violate phase sequence: execution first, checkpoints second, gateways third

Quality antipatterns:
- Never use vague descriptions in minimal execution set
- Never create placeholder steps
- Never leave ambiguous acceptance criteria
- Never exceed three dash items except for TDD cycle
- Never use backticks or code blocks in step text
- Never create steps requiring information not in contract

[PHASE BREAKER]: "<--- TRUST THE PROCESS --->"

-----

@___01_single_step___[ONE EXECUTION STAPPENPLAN]:
[INIT]01 = 01 EXEC STAPPENPLAN
Begin with single comprehensive vision statement. This statement captures entire project scope in one paragraph or sentence. Statement must be specific enough to guide all subsequent decomposition while broad enough to encompass full implementation. This is executive summary level. Answer: What is being built and why does it matter? This singular vision drives all subsequent refinement.

<--- TRUST THE PROCESS ----->

@___02_sequential_steps___[TWO EXECUTION STAPPENPLAN]:
[MITOSE]02 = 01 STAPPENPLAN + 01 STAPPENPLAN
Split single vision into two fundamental action steps through mitosis. Mitosis: 1 × 2 = 2. Primary dichotomy: preparation and execution. Or: design and implementation. Or: foundation and superstructure. Two steps represent highest-level work breakdown. Each step is abstract but shows major dependency. Step one must complete before step two begins. Pure execution steps only.

<--- TRUST THE PROCESS ----->

@___04_sequential_steps___[FOUR EXECUTION STAPPENPLAN]:
[MITOSE]04 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN
Take two action steps and apply mitosis to reach four execution steps. Mitosis: 2 × 2 = 4. Each of two steps splits into two sub-steps. Common patterns: for each original step, separate planning from execution or separate components. Four steps show major work packages. Each step represents substantial phase. Four steps provide high-level program visibility. Descriptions specify domain but remain abstract. Continue execution-only focus.

<--- TRUST THE PROCESS ----->

@___08_sequential_steps___[EIGHT EXECUTION STAPPENPLAN]:
[MITOSE]08 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN + 04 STAPPENPLAN
Take four action steps and apply mitosis to reach eight execution steps. Mitosis: 4 × 2 = 8. Each of four steps splits into two focused steps. Eight execution steps represent complete minimal action decomposition. This is the fixed execution step count. Each step is concrete work package. Eight steps provide implementer-level visibility into all major work streams. Descriptions specify what gets built or configured. This completes execution step mitosis. All subsequent phases calculate density based on these 8 fixed execution steps.

<--- TRUST THE PROCESS ----->

@___10_sequential_steps___[EIGHT EXECUTION PLUS TWO CHECKLISTS]:
[INIT]10 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN + 04 STAPPENPLAN + 02 CHECKLIST
Keep all eight execution steps fixed. Calculate initial checkpoint density: 8 exec steps / 4 = 2 checklists. Insert two validation checkpoint steps based on density of one checkpoint per four execution steps. These first checkpoints validate project foundation at strategic intervals across the 8 execution steps. Checkpoints define specific test files to create, list atomic tests to execute, reiterate one-test-one-validation principle, include TDD cycle guidance. Total: eight execution plus two checklists equals ten steps.

<--- TRUST THE PROCESS ----->

@___12_sequential_steps___[EIGHT EXECUTION PLUS FOUR CHECKLISTS]:
[MITOSE]12 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN + 04 STAPPENPLAN + 02 CHECKLIST + 02 CHECKLIST
Keep all eight execution steps fixed. Apply mitosis to checkpoints. Calculate new checkpoint density: 8 exec steps / 2 = 4 checklists. Double the checkpoint count from 2 to 4 through mitosis. New density is one checkpoint per two execution steps. Four checkpoints total provide comprehensive validation coverage across the 8 execution steps. Ratio: 8 execution to 4 validation = 2:1. Total: eight execution plus four checklists equals twelve steps. This completes checkpoint mitosis.

<--- TRUST THE PROCESS ----->

@___13_sequential_steps___[EIGHT EXECUTION PLUS FOUR CHECKLISTS PLUS ONE GATEWAY]:
[INIT]13 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN + 04 STAPPENPLAN + 02 CHECKLIST + 02 CHECKLIST + 01 GATEWAY
Keep all twelve steps fixed (8 execution + 4 checklists). Calculate initial gateway density: 8 exec steps / 8 = 1 gateway. Insert one release gateway step based on density of one gateway per eight execution steps. Gateway aggregates checkpoint results and adds integration tests spanning entire execution scope. Gateway format matches checkpoint format but tests span multiple domains. Gateway blocks progression until all prerequisites pass. Total: eight execution plus four checklists plus one gateway equals thirteen steps.

<--- TRUST THE PROCESS ----->

@___14_sequential_steps___[EIGHT EXECUTION PLUS FOUR CHECKLISTS PLUS TWO GATEWAYS]:
[MITOSE]14 = 01 STAPPENPLAN + 01 STAPPENPLAN + 02 STAPPENPLAN + 04 STAPPENPLAN + 02 CHECKLIST + 02 CHECKLIST + 01 GATEWAY + 01 GATEWAY
Keep all twelve steps fixed (8 execution + 4 checklists). Apply mitosis to gateways. Calculate new gateway density: 8 exec steps / 4 = 2 gateways. Double the gateway count from 1 to 2 through mitosis. New density is one gateway per four execution steps. Two gateways create staged release verification path. Each gateway has both automated tests and manual review criteria. Total: eight execution plus four checklists plus two gateways equals fourteen steps. Renumber all items sequentially STEP_01 through STEP_14. This is the final compact process.

-----

[END PROCESS DEFINITION]
