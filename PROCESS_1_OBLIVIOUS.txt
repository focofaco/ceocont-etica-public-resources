[INTRODUCTION]:
This document defines the deterministic methodology for planning complex implementation projects through iterative refinement. Start with high-level vision, progressively decompose into atomic executable steps, inject validation checkpoints at strategic intervals, and culminate with release gateways. Every step must be tangible, measurable, and executable. No ambiguity permitted.

[WRITING STYLE/TONE/VOICE]:
Assertive. Deterministic. Direct. Pragmatic. Hands-on. Zero fluff. Commands not suggestions. Facts not opinions. Concrete not abstract. Executable not theoretical. Present tense imperative. No optional elements. No maybe. No perhaps. Only MUST and MUST NOT.

[GUIDANCE FOR AI AGENT - INTERACTIVE EXECUTION]:
This is an interactive execution guide. When user says "next phase" or "proceed":
1. Read IMPLEMENTATION-PLAN.md completely
2. Count total STEP_XX entries present
3. Find the section below that starts with @___[your_current_count]_
4. Read ONLY that section - do NOT read ahead to sections you haven't reached
5. Execute that section's instructions
6. Add results below last "<--- TRUST THE PROCESS --->" separator in IMPLEMENTATION-PLAN.md
7. Commit and push
8. The process continues until you reach a section that says "Final sequence"

Formula interpretation:
- [INIT]: Initial step creation, starting point
- [SPLIT]: Decomposition of steps, revealing hidden complexity
- [DOUBLE]: Systematic doubling of step count through refinement
- Formula notation: shows transformation from one count to another
- Splitting logic: identify most complex steps, decompose into finer granularity

Iterative refinement mechanics:
- Begin with single high-level vision
- Progressively split into more steps: 1→3→6→12→24→36
- Each iteration maintains all previous work while adding detail
- Early iterations: strategic decomposition of major capabilities
- Middle iterations: tactical decomposition of work packages
- Late iterations: operational decomposition of specific tasks
- Renumber sequentially after each phase: STEP_01, STEP_02, STEP_03, etc.
- Preserve step content during renumbering, only update numbers

Step formatting rules:
- Implementation steps: STEP_XX: Brief imperative description
- Validation steps: STEP_XX: Brief validation description
- Checkpoint format: exactly three dash items plus optional fourth for TDD cycle
- Gateway format: similar to checkpoint but spans multiple domains
- Use plain text with dashes only, never use backticks or code blocks

Validation requirements:
- Every validation MUST specify exact test file path: tests/category/test-name.sh
- List atomic tests as comma-separated items
- One test equals one validation - never bundle multiple validations
- Always include TDD cycle guidance as fourth dash item
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

Checkpoint insertion strategy:
- Complete implementation decomposition before inserting first checkpoint
- Strategic placement after logical completion points
- Checkpoints validate cumulative implementation, not individual steps
- Domain-based grouping: structure, configuration, CI, integrity, release, publishing
- Incremental checkpoint addition: 6→12 checkpoints through splitting
- Each checkpoint split divides validation scope: core functionality vs edge cases

Gateway insertion strategy:
- Gateways mark major milestone boundaries
- Four primary gateways: foundation, validation infrastructure, core system, production
- Gateway expansion: 4→8 through splitting automated vs manual verification
- Automated gateways: deterministic test execution
- Manual gateways: human review with explicit checklists

[RUNTIME CHECKPOINT POLICY]:
Objective: Define checkpoint creation policy during execution sequence of implementation steps and gateways.

Step counting:
- Counting is 1-based: step 1, step 2, step 3, …
- Each execution of implementation step or gateway increments count by +1
- Checkpoint occurs at end of designated step, after successful execution
- Single unified counter: implementation steps and gateways both increment same counter

Phase 1 - Initial checkpoint after 4 steps:
- Rule: execute 4 steps without checkpoint, create checkpoint at end of 5th step
- Formula: if current_step = 5 → create checkpoint
- Usage: this initial phase applies only once at beginning of execution flow
- Rationale: larger initial window reduces checkpoint overhead when flow is still stable

Phase 2 - Checkpoints every 2 steps:
- After first checkpoint from Phase 1, pattern changes
- Rule: create checkpoint whenever 2 steps have executed since last checkpoint
- Equivalently: every interval of 2 steps, next step creates new checkpoint
- Formula:
  • Let k = step number where last checkpoint occurred
  • Next checkpoint must occur at step k + 3
  • After that, new k becomes this step number, repeat rule
- Practical interpretation: between one checkpoint and next, exactly 2 "pure" execution steps exist
- Sequence pattern: exec → exec → checkpoint → exec → exec → checkpoint → …
- Rationale: smaller window increases safety in critical or long execution phases

Timeline example (implementation steps):
Legend: E = normal execution step, C = execution with checkpoint creation at end

Step:   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
Action: E  E  E  E  C  E  E  C  E  E  C  E  E  C  E

Explanation:
- Steps 1–4: 4 executions without checkpoint (Phase 1)
- Step 5: execution + checkpoint (first checkpoint, ends Phase 1)
- Steps 6–7: 2 "pure" executions after checkpoint
- Step 8: execution + checkpoint
- Steps 9–10: 2 "pure" executions after checkpoint
- Step 11: execution + checkpoint
- Steps 12–13: 2 "pure" executions after checkpoint
- Step 14: execution + checkpoint
- Pattern continues indefinitely

Application to gateways:
- Gateways follow same counting and checkpoint policy as implementation steps
- Each gateway passage counts as 1 execution step
- Step counter does NOT differentiate between implementation step and gateway
- Implementation step or gateway both increment by +1
- Checkpoints occur at same step indices (5, 8, 11, 14, …) regardless of element type

Mixed example (implementation steps + gateways):
Step:      1    2      3  4    5      6  7    8
Element:   step step   gw step step   gw step step
Type:      E    E      E  E    C      E  E    C

- Steps 1–4: any combination of implementation steps/gateways, no checkpoint
- Step 5: element (implementation step or gateway) executes and creates checkpoint
- After: maintains "2 executions between checkpoints" rule

Operational summary:
- Initialize step_counter = 0
- At each execution of implementation step or gateway:
  1) step_counter ← step_counter + 1
  2) if step_counter = 5 → create checkpoint (end Phase 1)
  3) after first checkpoint:
     - maintain last_checkpoint = step where checkpoint occurred
     - if step_counter = last_checkpoint + 3 → create new checkpoint
     - update last_checkpoint ← step_counter

MUST follow this policy. No exceptions. No deviations. Deterministic checkpoint creation ensures consistent recovery points throughout execution flow.

[SYNTAX]:
Phase separator: <--- TRUST THE PROCESS --->
Step format implementation: STEP_XX: Brief imperative description
Step format validation: STEP_XX: Brief validation description
Validation structure:
- Create tests/category/test-name.sh with fixtures if needed
- Tests: atomic test list, comma-separated
- All tests atomic: 1 test = 1 validation
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

[PATTERNS]:
Start vague, end precise. Identify complex steps, split them. Insert checkpoints after logical completion points. Validation steps are not implementation steps. Keep ratios: implementation to validation approximately 3:1. Checkpoints validate cumulative work, not single steps. Group validations by domain: structure, configuration, CI, integrity, release, publishing.

Phase progression patterns:
- Phase 1 (single step): Executive summary level, entire project scope in one statement
- Phase 2 (three steps): Highest-level work breakdown, sequential dependency, major phase boundaries
- Phase 3 (six steps): Program management visibility, major work streams, substantial deliverables
- Phase 4 (twelve steps): Technical leadership visibility, focused work packages, execution sequence
- Phase 5 (twenty-four steps): Senior implementer visibility, detailed execution path, critical dependencies
- Phase 6 (thirty-six steps): Implementer granularity, comprehensive plan, exact artifacts

Splitting and doubling patterns:
- Splitting: identify most complex steps from previous phase, decompose into constituent parts
- Doubling: systematic increase from N to 2N steps through targeted decomposition
- Target selection: choose steps with highest complexity, broadest scope, most hidden dependencies
- Decomposition strategy: reveal sequential phases within complex steps, expose parallel work streams
- Granularity calibration: maintain appropriate detail level for current phase

Step description patterns:
- Phase 1: Paragraph capturing full vision
- Phase 2-3: High-level capability statements
- Phase 4-5: Work package descriptions with scope
- Phase 6: Specific task descriptions with artifacts
- Use imperative mood throughout
- Maintain measurable outcomes at every level
- Increase specificity through phases: conceptual → tactical → operational

Validation insertion patterns:
- Complete all implementation decomposition first (reach phase 6 with 36 steps)
- Insert six checkpoints at strategic completion boundaries
- Domain-based checkpoint placement: structure, config, CI, integrity, release, publishing
- Each checkpoint validates cumulative work in its domain
- Checkpoint splitting: core functionality vs edge cases/integration
- Checkpoint expansion: 6 → 12 through systematic splitting

Gateway insertion patterns:
- Add four gateways at major milestone boundaries
- Gateway positioning: after checkpoints are placed
- Each gateway aggregates multiple checkpoint results
- Gateway content: automated tests + manual review criteria
- Gateway splitting: automated verification vs manual review
- Gateway expansion: 4 → 8 through verification type separation

Ratio and balance patterns:
- Target implementation:validation ratio approximately 3:1
- Phase 6: 36 implementation steps provides foundation
- Checkpoint phase: add 6 then 12 validations (36:12 = 3:1)
- Gateway phase: add 4 then 8 release gates
- Final balance: 36 implementation + 12 validation + 8 gateway = 56 total

[ANTIPATTERNS]:
Never use letters for step numbering in final output. Never exceed three dash items except for TDD guidance. Never write code in process steps. Never use examples with specific values unless from contract. Never batch multiple implementations into one step at final level. Never create validation without specifying test file path. Never forget TDD cycle guidance. Never use magic numbers in validation criteria. Never reference tools that don't exist yet.

Splitting and doubling antipatterns:
- Never split low-complexity steps while high-complexity steps remain unsplit
- Never double by creating duplicate steps instead of proper decomposition
- Never maintain same abstraction level when doubling - must add detail
- Never split evenly - target most complex steps for decomposition
- Never double implementation and validation simultaneously
- Never skip intermediate doubling phases trying to jump to final count

Numbering and formatting antipatterns:
- Never skip renumbering after splitting or doubling
- Never use non-sequential numbering after expansion
- Never lose track of step count during splitting phases
- Never forget to update STEP_XX numbers when inserting validations
- Never use inconsistent numbering schemes within same plan

Step content antipatterns:
- Never write vague descriptions at any phase
- Never include implementation code in step descriptions
- Never create steps with multiple unrelated concerns
- Never use conditional logic in step descriptions
- Never create unverifiable steps without measurable outcomes
- Never use passive voice in step descriptions
- Never include optional elements or tentative phrasing
- Never batch multiple tasks into one step at final implementation granularity

Dependency antipatterns:
- Never create circular dependencies between steps
- Never reference future steps not yet created
- Never violate topological order during splitting
- Never assume implicit dependencies without making them explicit
- Never create checkpoints that validate steps not yet implemented
- Never design gateways that depend on validations not yet inserted

Validation antipatterns:
- Never create validation steps without exact test file path
- Never bundle multiple unrelated tests in single validation
- Never forget TDD cycle guidance in checkpoint dash items
- Never use relative file paths in test specifications
- Never hard-code values that should come from contract
- Never create tests requiring manual intervention without review criteria
- Never write validations that test implementation details instead of behavior
- Never omit edge case and negative test coverage
- Never violate 3:1 implementation:validation ratio significantly

Phase progression antipatterns:
- Never add too much detail too early in splitting sequence
- Never stay too abstract too late in splitting sequence
- Never insert checkpoints before completing implementation decomposition
- Never add gateways before completing checkpoint insertion
- Never read ahead to future phases before reaching them
- Never skip implementation doubling phases
- Never violate three-phase structure: implementation, validation, gateway

Quality antipatterns:
- Never use placeholder text like TODO or TBD
- Never leave ambiguous acceptance criteria
- Never create steps requiring information not available in contract
- Never write implementation-specific steps when contract is technology-agnostic
- Never exceed three dash items in checkpoints except for TDD cycle
- Never use backticks, code blocks, or formatted code in step text
- Never create steps that require external documentation to complete
- Never reference tools, frameworks, or dependencies not yet created in earlier steps

Strategic antipatterns:
- Never place checkpoints at arbitrary positions - follow domain boundaries
- Never create low-value checkpoints testing trivial operations
- Never omit checkpoints for high-risk or complex operations
- Never design gateways that merely duplicate checkpoint tests
- Never create manual review gates without specific review checklists
- Never position gateways within phases instead of at major milestone boundaries
- Never split checkpoints unevenly - balance core vs edge case coverage
- Never split gateways arbitrarily - separate automated from manual verification

[PHASE BREAKER]: "<--- TRUST THE PROCESS --->"

-----

@___01_single_step___[ONE STEP STAPPENPLAN]:
[INIT]01 = 01 STAPPENPLAN
Begin with single comprehensive vision statement. This statement captures entire project scope in one paragraph or sentence. Statement must be specific enough to guide all subsequent decomposition while broad enough to encompass full implementation. This is executive summary level. Answer: What is being built and why does it matter? This singular vision drives all subsequent refinement.

<--- TRUST THE PROCESS ----->

@___03_sequential_steps___[THREE STEPS STAPPENPLAN]:
[SPLIT]03 = 01 STAPPENPLAN × 3
Take the single vision and split into three fundamental phases. Splitting: 1 × 3 = 3. Common patterns: beginning, middle, end. Or: setup, execute, verify. Or: foundation, build, deliver. Three steps show minimal viable progression through project lifecycle. Each step represents major phase boundary. These three STAPPENPLAN provide highest-level work breakdown showing sequential dependency. Descriptions remain abstract but establish project rhythm.

<--- TRUST THE PROCESS ----->

@___06_sequential_steps___[SIX STEPS STAPPENPLAN]:
[DOUBLE]06 = 03 STAPPENPLAN × 2
Take the three fundamental phases and double to six high-level steps that map the entire journey from initial setup to final delivery. Doubling: 3 × 2 = 6. Each step represents a major capability milestone. Steps must be sequential and build upon each other. No step can start before its predecessor completes. These six STAPPENPLAN provide executive-level visibility into project structure without implementation details. Use simple present tense descriptions focusing on outcomes not methods.

<--- TRUST THE PROCESS ----->

@___12_sequential_steps___[TWELVE INFERED STEPS STAPPENPLAN]:
[DOUBLE]12 = 06 STAPPENPLAN × 2
Take each of the six phases and decompose into two logical sub-phases, yielding twelve steps total. Doubling: 6 × 2 = 12. Each split reveals one preparatory step and one execution step, or one design step and one implementation step. Maintain sequential dependency chain. These twelve STAPPENPLAN provide mid-level management visibility showing how each major phase breaks down into actionable chunks. Descriptions remain outcome-focused but hint at method.

<--- TRUST THE PROCESS ----->

@___24_sequential_steps___[TWENTY FOUR INFERED STEPS STAPPENPLAN]:
[DOUBLE]24 = 12 STAPPENPLAN × 2
Take each of the twelve steps and split into two granular steps, yielding twenty-four steps total. Doubling: 12 × 2 = 24. Some splits separate planning from execution. Others separate component A from component B. Others separate write from test. Each step now represents a distinct deliverable or artifact. These twenty-four STAPPENPLAN provide technical lead visibility into implementation sequence. Descriptions must be specific about what gets created or configured.

<--- TRUST THE PROCESS ----->

@___36_sequential_steps___[THIRTY SIX SAME 24 + 12-COMPLEX-ONLY-SET INFERED STEPS STAPPENPLAN]:
[SPLIT]36 = 24 STAPPENPLAN + 12 STAPPENPLAN
Keep all twenty-four steps. Identify the twelve most complex steps based on: multiple sub-concerns, high cognitive load, error-prone nature, or critical path position. Split each of these twelve complex steps into two sub-steps using a/b notation initially or direct expansion. Splitting: 24 + 12 = 36. Result: twelve simple steps remain as-is, twelve complex steps become twenty-four detailed steps, total equals thirty-six STAPPENPLAN. These thirty-six STAPPENPLAN provide implementer visibility into every discrete action required. Descriptions specify exact artifacts, commands, or configurations.

<--- TRUST THE PROCESS ----->

@___42_sequential_steps___[EACH SIX CHECKPOINTS STAPPENPLAN]:
[INIT]42 = 36 STAPPENPLAN + 06 CHECKLIST
Keep all thirty-six implementation STAPPENPLAN. Insert six validation checkpoint steps at strategic completion boundaries: after directory structure, after configuration, after CI pipeline, after integrity system, after release automation, after publishing system. Each checkpoint defines specific test files to create, lists atomic tests to execute, reiterates one-test-one-validation principle, and includes TDD cycle guidance as fourth dash. Checkpoints validate cumulative implementation, not individual STAPPENPLAN. Position checkpoints where failure would invalidate subsequent work. Total: thirty-six STAPPENPLAN plus six validation equals forty-two steps.

<--- TRUST THE PROCESS ----->

@___48_sequential_steps___[EACH THREE INFERED CHECKPOINTS STAPPENPLAN]:
[DOUBLE]48 = 36 STAPPENPLAN + 12 CHECKLIST
Keep all thirty-six implementation STAPPENPLAN. Split each of six checkpoints into two focused validation steps, yielding twelve validation steps total. Doubling validation: 6 × 2 = 12. First validation in each pair tests core functionality, second tests edge cases or integration. For example: directory structure splits into base directories validation and category directories validation. Configuration splits into limits validation and naming rules validation. CI splits into reject-invalid validation and accept-valid validation. Integrity splits into hash generation and tree determinism. Release splits into changelog and versioning. Publishing splits into upload and compliance. Total: thirty-six STAPPENPLAN plus twelve validation equals forty-eight steps. Renumber all steps sequentially as STEP_01 through STEP_48.

<--- TRUST THE PROCESS ----->

@___52_sequential_steps___[EACH FOUR RELEASE GATEWAY STAPPENPLAN]:
[INIT]52 = 48 STEPS + 04 GATEWAY
Keep all forty-eight steps from previous phase. Insert four release gateway steps at major milestone boundaries: after STEP_10 as GATEWAY_01 verifying foundation readiness, after STEP_21 as GATEWAY_02 verifying validation infrastructure readiness, after STEP_31 as GATEWAY_03 verifying core system readiness, after STEP_48 as GATEWAY_04 verifying production readiness. Each gateway aggregates multiple checkpoint results and adds integration smoke tests. Gateway format matches checkpoint format but tests span multiple domains. Gateways block progression until all prerequisites pass. Total: forty-eight steps plus four gateways equals fifty-two steps.

<--- TRUST THE PROCESS ----->

@___56_sequential_steps___[EACH FOUR FINAL RELEASE GATEWAY STAPPENPLAN]:
[DOUBLE]56 = 48 STEPS + 08 GATEWAY
Keep all forty-eight steps and four gateways from previous phase. Split each of four gateways into two sub-gateways: automated verification gateway and manual review gateway. Doubling gateways: 4 × 2 = 8. Automated gateway runs deterministic tests. Manual gateway requires human sign-off on non-deterministic criteria: documentation completeness, architecture review, security audit, performance benchmarks. Each manual gateway specifies exact review checklist. Total: forty-eight steps plus eight gateways equals fifty-six steps. Renumber gateways as GATEWAY_01 through GATEWAY_08. Final sequence: STEP_01, STEP_02, ..., GATEWAY_01, GATEWAY_02, ..., STEP_XX, ..., GATEWAY_07, GATEWAY_08, STEP_48.

-----

[END PROCESS DEFINITION]
