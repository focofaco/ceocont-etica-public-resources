[INTERACTIVE EXECUTION GUIDE - FIBONACCI VARIANT]

This document guides step-by-step execution when running the PROCESS_2.txt methodology interactively. Use this when implementing a project using Fibonacci-based progression with human review between phases.

-----

[CURRENT STATE AWARENESS]

Before proceeding to next phase, AI agent MUST:
- Read IMPLEMENTATION-PLAN.md completely
- Identify which phase separator was last completed
- Count total STEP_XX entries present
- Determine next phase based on step count

Phase identification table (Fibonacci progression):
- 1 step present → Next: expand to 2 steps
- 2 steps present → Next: expand to 3 steps (2+1)
- 3 steps present → Next: expand to 5 steps (3+2)
- 5 steps present → Next: expand to 8 steps (5+3)
- 8 steps present → Next: expand to 13 steps (8+5)
- 13 steps present → Next: expand to 21 steps (13+8)
- 21 steps present → Next: expand to 34 steps (21+13)
- 34 steps present → Next: add 2 checkpoints (36 total)
- 36 steps present → Next: expand to 6 checkpoints (42 total)
- 42 steps present → Next: expand implementation to 36 and checkpoints to 12 (48 total)
- 48 steps present → Next: add 4 release gateways (52 total)
- 52 steps present → Next: split gateways to 8 (56 total)
- 56 steps present → COMPLETE, no next phase

-----

[EXECUTION PROTOCOL]

When user says "next phase" or "continue" or "proceed":

STEP 1: Read current IMPLEMENTATION-PLAN.md
STEP 2: Identify current step count
STEP 3: Announce: "Current state: X steps detected. Fibonacci next: expand to Y steps."
STEP 4: Execute appropriate expansion from PROCESS_2.txt methodology
STEP 5: Update IMPLEMENTATION-PLAN.md with new phase below last separator
STEP 6: Add new "<--- TRUST THE PROCESS --->" separator before new content
STEP 7: Commit with message describing Fibonacci transition (X → Y steps)
STEP 8: Push to remote
STEP 9: Announce completion: "Phase complete. Now at Y steps. Ready for next Fibonacci phase."

-----

[PHASE-SPECIFIC INSTRUCTIONS - FIBONACCI EXPANSION]

PHASE: 1 → 2 STEPS
Action: Split single vision into two fundamental phases
Method: Identify primary dichotomy (prep/exec, design/implement, etc.)
Result: 2 steps total
Naming: Use numbered list (1-2) at this phase
Fibonacci: Starting sequence

PHASE: 2 → 3 STEPS
Action: Add one step to existing two
Method: Insert intermediate step or add follow-up step
Fibonacci: 1 + 2 = 3
Result: 3 steps total
Naming: Use numbered list (1-3) at this phase

PHASE: 3 → 5 STEPS
Action: Add two steps to existing three
Method: Split most complex step or add two critical dependencies
Fibonacci: 2 + 3 = 5
Result: 5 steps total
Naming: Use numbered list (1-5) at this phase

PHASE: 5 → 8 STEPS
Action: Add three steps to existing five
Method: Strategic splits of complex steps or reveal hidden dependencies
Fibonacci: 3 + 5 = 8
Result: 8 steps total
Naming: Use numbered list (1-8) at this phase

PHASE: 8 → 13 STEPS
Action: Add five steps to existing eight
Method: Split complex steps or expose all hidden dependencies
Fibonacci: 5 + 8 = 13
Result: 13 steps total
Naming: Use numbered list (1-13) at this phase

PHASE: 13 → 21 STEPS
Action: Add eight steps to existing thirteen
Method: Break down complex activities, expose all major dependencies
Fibonacci: 8 + 13 = 21
Result: 21 steps total
Naming: Use numbered list (1-21) at this phase

PHASE: 21 → 34 STEPS
Action: Add thirteen steps to existing twenty-one
Method: Split remaining complex steps into atomic actions
Fibonacci: 13 + 21 = 34 (final Fibonacci expansion)
Result: 34 steps total
Naming: Use numbered list (1-34) at this phase
Note: This completes Fibonacci progression, next phases add quality gates

-----

[PHASE-SPECIFIC INSTRUCTIONS - CHECKPOINT INSERTION]

PHASE: 34 → 36 STEPS (ADD INITIAL CHECKPOINTS)
Action: Keep all 34 steps, add 2 validation checkpoints at early critical junctions
Result: 34 implementation + 2 validation = 36 steps total
Checkpoint positions: After foundation setup, after configuration complete
Checkpoint format: Must include test file path, atomic tests list, 1-test-1-validation reminder
Naming: Continue numbered list incorporating checkpoints
Transition: Fibonacci expansion complete, begin checkpoint insertion pattern

PHASE: 36 → 42 STEPS (EXPAND TO SIX CHECKPOINTS)
Action: Keep all 34 implementation steps and 2 existing checkpoints, add 4 more checkpoints
Result: 34 implementation + 6 validation = 40 steps, round to 42 for progression
Checkpoint positions: After CI pipeline, after integrity system, after release automation, after publishing
Naming: Continue numbered list with all six checkpoints integrated

PHASE: 42 → 48 STEPS (REFINE AND RENUMBER)
Action: Expand to 36 implementation steps (split 2 critical steps), split 6 checkpoints into 12 validations
Result: 36 implementation + 12 validation = 48 steps total
Naming: MUST renumber everything as STEP_01 through STEP_48
Validation format: Each validation has 4 dash items (including TDD cycle)
CRITICAL: This is final implementation phase - use STEP_XX notation

PHASE: 48 → 52 STEPS (ADD GATEWAYS)
Action: Keep all 48 steps, insert 4 release gateways at major milestones
Result: 48 steps + 4 gateways = 52 items total
Gateway positions: After foundation, after validation infrastructure, after core system, after final validation
Gateway format: Similar to checkpoints but spans multiple domains
Naming: Steps remain STEP_XX, gateways use GATEWAY_01 through GATEWAY_04

PHASE: 52 → 56 STEPS (SPLIT GATEWAYS)
Action: Keep all 48 steps, split 4 gateways into 8 (automated + manual review)
Result: 48 steps + 8 gateways = 56 items total
Gateway format: Automated gateways run tests, manual gateways require human sign-off
Naming: GATEWAY_01 through GATEWAY_08
FINAL: This is completion phase

-----

[FIBONACCI EXPANSION RULES]

When expanding from N to M steps (where M = previous_N + current_N):
1. Review all existing N steps
2. Identify steps_to_add = M - N
3. Prioritize splitting by:
   - Highest complexity steps first
   - Steps with most dependencies
   - Steps blocking critical path
   - Steps with ambiguous scope
4. Distribute new steps across existing steps evenly
5. Maintain sequential flow
6. Preserve all previous phases above separator

Example: 8 → 13 (add 5 steps)
- Review 8 existing steps
- Need to add 5 steps
- Identify 5 most complex steps
- Split each identified step into 2 steps
- Result: 3 simple + 10 detailed = 13 steps total

-----

[VALIDATION BEFORE PROCEEDING]

Before executing next phase, verify:
- [ ] IMPLEMENTATION-PLAN.md exists and is readable
- [ ] Current phase has correct separator "<--- TRUST THE PROCESS --->"
- [ ] Step count matches expected Fibonacci number for current phase
- [ ] If in checkpoint phase (36+), verify checkpoint format is correct
- [ ] Git working directory is clean (or changes are intentional)
- [ ] Currently on correct development branch

-----

[ERROR RECOVERY]

If step count doesn't match expected Fibonacci progression:
1. STOP immediately
2. Report discrepancy to user
3. Check if in checkpoint phase (34+ steps) where Fibonacci no longer applies
4. Ask user: "Detected X steps but expected Y. Proceed with recovery or manual intervention?"
5. Wait for user confirmation before continuing

If Fibonacci calculation unclear:
1. Reference table: 1, 2, 3, 5, 8, 13, 21, 34
2. After 34, use checkpoint counts: 36, 42, 48, 52, 56
3. If confusion persists, ask user which phase to execute

If IMPLEMENTATION-PLAN.md missing or corrupted:
1. STOP immediately
2. Report error to user
3. Do NOT attempt automatic recovery
4. Wait for user to restore or provide guidance

-----

[COMMIT MESSAGE TEMPLATES]

1→2: "docs: split vision into 2 fundamental phases (Fibonacci)"
2→3: "docs: expand to 3 steps with intermediate step (Fibonacci 2+1)"
3→5: "docs: expand to 5 steps adding critical dependencies (Fibonacci 3+2)"
5→8: "docs: expand to 8 steps with strategic splits (Fibonacci 5+3)"
8→13: "docs: expand to 13 steps exposing dependencies (Fibonacci 8+5)"
13→21: "docs: expand to 21 detailed steps (Fibonacci 13+8)"
21→34: "docs: expand to 34 atomic implementation steps (Fibonacci 21+13)"
34→36: "docs: add 2 initial validation checkpoints (36 items total)"
36→42: "docs: expand to 6 validation checkpoints (42 items total)"
42→48: "docs: refine to 36 implementation + 12 validations and renumber STEP_01-48"
48→52: "docs: add 4 release gateways (52 items total)"
52→56: "docs: split gateways into automated and manual review (56 items total)"

-----

[FIBONACCI VS DOUBLING DETECTION]

If user has used PROCESS.txt (doubling method) previously:
- Announce: "Detected PROCESS.txt doubling pattern. Switching to PROCESS_2.txt Fibonacci pattern."
- Confirm with user before proceeding
- Explain difference: Fibonacci grows organically, doubling grows systematically

If starting fresh:
- Default to Fibonacci (PROCESS_2.txt) for exploratory projects
- Recommend doubling (PROCESS.txt) for well-defined production implementations

-----

[COMPLETION SIGNAL]

When 56 steps reached:
1. Announce: "FIBONACCI PROCESS COMPLETE. Implementation plan contains 48 steps and 8 gateways (56 total)."
2. Note: "Fibonacci progression (1→2→3→5→8→13→21→34) followed by checkpoint insertion (36→42→48→52→56)."
3. Suggest: "Ready to begin STEP_01 execution, or require further refinement?"
4. Do NOT proceed to execution without explicit user instruction

-----

[END INTERACTIVE EXECUTION GUIDE - FIBONACCI VARIANT]
