[INTRODUCTION]:
This document defines a methodology for planning complex implementation projects through organic growth. Start with single vision statement, expand through natural complexity scaling, then transition to checkpoint insertion pattern. Every step must be tangible, measurable, and executable. No ambiguity permitted.

[WRITING STYLE/TONE/VOICE]:
Assertive. Deterministic. Direct. Pragmatic. Hands-on. Zero fluff. Commands not suggestions. Facts not opinions. Concrete not abstract. Executable not theoretical. Present tense imperative. No optional elements. No maybe. No perhaps. Only MUST and MUST NOT.

[GUIDANCE FOR AI AGENT - INTERACTIVE EXECUTION]:
This is an interactive execution guide. When user says "next phase" or "proceed":
1. Read IMPLEMENTATION-PLAN.md completely
2. Count total STEP_XX entries present
3. Find the section below that starts with @___[your_current_count]_
4. Read ONLY that section - do NOT read ahead to sections you haven't reached
5. Execute that section's instructions
6. Add results below last "<--- TRUST THE PROCESS --->" separator in IMPLEMENTATION-PLAN.md
7. Commit and push
8. Organic expansion creates natural complexity growth. After completing execution expansion, switch to checkpoint insertion pattern

Formula interpretation:
- [INIT]: Initial step creation, starting point
- [FIBONACCI]: Growth following natural progression pattern
- [EXPAND]: Addition of new steps building on previous work
- Formula notation: shows how current phase builds on previous phase results
- Expansion logic: each phase adds steps based on previous phase counts

Organic expansion mechanics:
- Early phases: slow growth, stay abstract, establish foundation
- Middle phases: accelerated growth, add specificity, reveal dependencies
- Late phases: comprehensive detail, concrete implementation guidance
- Maintain ALL previous steps when expanding to next phase
- Add new steps according to phase instructions
- Renumber sequentially after each phase: STEP_01, STEP_02, STEP_03, etc.
- Preserve step content during renumbering, only update numbers

Step formatting rules:
- Implementation steps: STEP_XX: Brief imperative description
- Validation steps: STEP_XX: Brief validation description
- Checkpoint format: exactly three dash items plus optional fourth for TDD cycle
- Gateway format: similar to checkpoint but spans multiple domains
- Use plain text with dashes only, never use backticks or code blocks

Validation requirements:
- Every validation MUST specify exact test file path: tests/category/test-name.sh
- List atomic tests as comma-separated items
- One test equals one validation - never bundle multiple validations
- Always include TDD cycle guidance as fourth dash item
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

Transition strategy:
- Execution expansion phase: focus purely on implementation steps, no validations yet
- Transition point: when execution steps reach sufficient detail for comprehensive implementation
- Checkpoint insertion phase: add strategic validations to completed execution plan
- Gateway insertion phase: add release verification after checkpoints complete
- Never mix execution expansion with validation insertion in same phase

[RUNTIME CHECKPOINT POLICY]:
Objective: Define checkpoint creation policy during execution sequence of implementation steps and gateways.

Step counting:
- Counting is 1-based: step 1, step 2, step 3, …
- Each execution of implementation step or gateway increments count by +1
- Checkpoint occurs at end of designated step, after successful execution
- Single unified counter: implementation steps and gateways both increment same counter

Phase 1 - Initial checkpoint after 4 steps:
- Rule: execute 4 steps without checkpoint, create checkpoint at end of 5th step
- Formula: if current_step = 5 → create checkpoint
- Usage: this initial phase applies only once at beginning of execution flow
- Rationale: larger initial window reduces checkpoint overhead when flow is still stable

Phase 2 - Checkpoints every 2 steps:
- After first checkpoint from Phase 1, pattern changes
- Rule: create checkpoint whenever 2 steps have executed since last checkpoint
- Equivalently: every interval of 2 steps, next step creates new checkpoint
- Formula:
  • Let k = step number where last checkpoint occurred
  • Next checkpoint must occur at step k + 3
  • After that, new k becomes this step number, repeat rule
- Practical interpretation: between one checkpoint and next, exactly 2 "pure" execution steps exist
- Sequence pattern: exec → exec → checkpoint → exec → exec → checkpoint → …
- Rationale: smaller window increases safety in critical or long execution phases

Timeline example (implementation steps):
Legend: E = normal execution step, C = execution with checkpoint creation at end

Step:   1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
Action: E  E  E  E  C  E  E  C  E  E  C  E  E  C  E

Explanation:
- Steps 1–4: 4 executions without checkpoint (Phase 1)
- Step 5: execution + checkpoint (first checkpoint, ends Phase 1)
- Steps 6–7: 2 "pure" executions after checkpoint
- Step 8: execution + checkpoint
- Steps 9–10: 2 "pure" executions after checkpoint
- Step 11: execution + checkpoint
- Steps 12–13: 2 "pure" executions after checkpoint
- Step 14: execution + checkpoint
- Pattern continues indefinitely

Application to gateways:
- Gateways follow same counting and checkpoint policy as implementation steps
- Each gateway passage counts as 1 execution step
- Step counter does NOT differentiate between implementation step and gateway
- Implementation step or gateway both increment by +1
- Checkpoints occur at same step indices (5, 8, 11, 14, …) regardless of element type

Mixed example (implementation steps + gateways):
Step:      1    2      3  4    5      6  7    8
Element:   step step   gw step step   gw step step
Type:      E    E      E  E    C      E  E    C

- Steps 1–4: any combination of implementation steps/gateways, no checkpoint
- Step 5: element (implementation step or gateway) executes and creates checkpoint
- After: maintains "2 executions between checkpoints" rule

Operational summary:
- Initialize step_counter = 0
- At each execution of implementation step or gateway:
  1) step_counter ← step_counter + 1
  2) if step_counter = 5 → create checkpoint (end Phase 1)
  3) after first checkpoint:
     - maintain last_checkpoint = step where checkpoint occurred
     - if step_counter = last_checkpoint + 3 → create new checkpoint
     - update last_checkpoint ← step_counter

MUST follow this policy. No exceptions. No deviations. Deterministic checkpoint creation ensures consistent recovery points throughout execution flow.

[SYNTAX]:
Phase separator: <--- TRUST THE PROCESS --->
Step format implementation: STEP_XX: Brief imperative description
Step format validation: STEP_XX: Brief validation description
Validation structure:
- Create tests/category/test-name.sh with fixtures if needed
- Tests: atomic test list, comma-separated
- All tests atomic: 1 test = 1 validation
- TDD cycle: write test, run test (fail), implement feature, run test (pass), refactor if needed, run test (pass)

[PATTERNS]:
Start minimal, grow organically. Each expansion adds detail based on previous step counts. Early phases grow slowly, middle phases accelerate. After completing execution steps, switch to checkpoint insertion. Natural information density progression emerges. Later phases focus on validation and quality gates rather than feature expansion.

Phase progression patterns:
- Phase 1: Single vision statement, highest abstraction, project-level scope
- Phase 2-3: Major capability domains emerge, program-level decomposition
- Phase 4-5: Work packages defined, technical leadership visibility
- Phase 6-7: Detailed task breakdown, implementer-level granularity, comprehensive coverage
- Phase 8+: Validation insertion, checkpoint saturation, gateway creation

Organic growth patterns:
- Growth accelerates naturally: early phases add fewer steps, later phases add more
- Each expansion builds on all previous expansions
- Complexity emerges gradually without forcing premature detail
- Natural discovery of hidden dependencies and implicit requirements
- Information density increases organically from abstract to concrete

Step description patterns:
- Early phases: paragraph-level conceptual descriptions, strategic capabilities
- Middle phases: sentence-level work package descriptions, tactical capabilities
- Late phases: precise task descriptions, operational details
- Use imperative mood throughout: "Create", "Configure", "Implement"
- Maintain measurable outcomes: each step produces verifiable artifact

Dependency management patterns:
- Early phases establish high-level sequence: foundation → build → verify
- Middle phases reveal dependency chains between capabilities
- Late phases expose fine-grained dependencies between tasks
- Maintain topological order: dependencies always come before dependents
- Sequential checkpoints validate dependency satisfaction progressively

Validation patterns:
- Complete all execution expansion before adding first checkpoint
- Strategic checkpoint placement at capability boundaries
- Incremental checkpoint addition: start with few, grow to comprehensive coverage
- Test file organization: tests/category/test-name.sh
- Atomic test definitions: one test one validation
- Gateway placement at major milestones after checkpoint saturation

Natural information density patterns:
- Abstraction level decreases through phases: conceptual → tactical → operational
- Specificity increases through phases: what → how → exactly how
- Granularity increases through phases: programs → packages → tasks
- Verification rigor increases through phases: none → checkpoints → gateways
- Each phase reveals information hidden in previous abstractions

[ANTIPATTERNS]:
Never use letters for step numbering in final output. Never exceed three dash items except for TDD guidance. Never write code in process steps. Never use examples with specific values unless from contract. Never create validation without specifying test file path. Never forget TDD cycle guidance. Never use magic numbers in validation criteria.

Organic growth antipatterns:
- Never force premature detail in early phases
- Never stay too abstract in late phases
- Never skip intermediate phases trying to jump directly to implementation detail
- Never lose the organic progression by making all phases equally detailed
- Never add checkpoints during execution expansion phases
- Never continue execution expansion after transition to validation phase

Numbering and formatting antipatterns:
- Never skip renumbering after any expansion
- Never use non-sequential numbering
- Never lose track of step count between phases
- Never forget to preserve step content during renumbering
- Never mix numbering schemes within same plan

Step content antipatterns:
- Never write vague descriptions at any phase
- Never include code or commands in step descriptions
- Never create steps with multiple unrelated concerns
- Never use conditional logic in steps
- Never create unverifiable steps
- Never use passive voice
- Never include optional elements

Dependency antipatterns:
- Never create circular dependencies
- Never reference steps not yet created
- Never violate topological order
- Never assume implicit dependencies
- Never create checkpoints before their target steps exist
- Never design gateways depending on non-existent validations

Validation antipatterns:
- Never create validation without exact test file path
- Never bundle multiple unrelated tests
- Never forget TDD cycle guidance
- Never use relative paths
- Never hard-code values from contract
- Never write validations testing implementation instead of behavior
- Never omit edge cases and negative tests

Expansion mechanics antipatterns:
- Never lose previous steps when expanding
- Never modify existing step content during expansion
- Never skip phases
- Never read ahead to future phases
- Never combine expansion with validation insertion
- Never violate phase separation
- Never change the expansion pattern mid-process

Quality antipatterns:
- Never use placeholders like TODO or TBD
- Never leave ambiguous criteria
- Never require information not in contract
- Never create technology-specific steps when contract is agnostic
- Never exceed three dash items except for TDD
- Never use code formatting in plain text
- Never require external documentation

Strategic antipatterns:
- Never place checkpoints arbitrarily
- Never create trivial low-value checkpoints
- Never omit checkpoints for high-risk operations
- Never make gateways that duplicate checkpoint tests
- Never create review gates without specific criteria
- Never position gateways mid-phase instead of at boundaries

[PHASE BREAKER]: "<--- TRUST THE PROCESS --->"

-----

@___01_single_step___[ONE STEP STAPPENPLAN]:
[INIT]01 = 01 STAPPENPLAN
Begin with single comprehensive vision statement. This statement captures entire project scope in one paragraph. Statement must be specific enough to guide all subsequent decomposition while broad enough to encompass full implementation. This is executive summary level. Answer: What is being built and why does it matter?

<--- TRUST THE PROCESS ----->

@___02_sequential_steps___[TWO STEPS STAPPENPLAN]:
[FIBONACCI]02 = 01 STAPPENPLAN + 01 STAPPENPLAN
Split the single vision into two fundamental phases: preparation and execution. Or: design and implementation. Or: foundation and superstructure. Whatever dichotomy best serves the project. Fibonacci: 1 + 1 = 2. These two steps represent the highest-level work breakdown. Each step is still quite abstract but shows major dependency. Step one must complete before step two begins.

<--- TRUST THE PROCESS ----->

@___03_sequential_steps___[THREE STEPS STAPPENPLAN]:
[FIBONACCI]03 = 01 STAPPENPLAN + 02 STAPPENPLAN
Fibonacci expansion: previous two step counts (1 + 2 = 3). Take the two steps and expand by adding one new intermediate or follow-up step. Common patterns: beginning, middle, end. Or: setup, core work, teardown. Or: build, test, deploy. Three steps show minimal viable progression through project lifecycle. Steps remain high-level but show sequence.

<--- TRUST THE PROCESS ----->

@___05_sequential_steps___[FIVE STEPS STAPPENPLAN]:
[FIBONACCI]05 = 02 STAPPENPLAN + 03 STAPPENPLAN
Fibonacci expansion: previous two step counts (2 + 3 = 5). Take the three steps and add two more steps by splitting most complex step or adding critical dependencies. Five steps typically map to major capability domains. Each step represents substantial deliverable or milestone. Five steps provide program management visibility into major work streams. Descriptions specify domain but not implementation details.

<--- TRUST THE PROCESS ----->

@___08_sequential_steps___[EIGHT STEPS STAPPENPLAN]:
[FIBONACCI]08 = 03 STAPPENPLAN + 05 STAPPENPLAN
Fibonacci expansion: previous two step counts (3 + 5 = 8). Take the five steps and add three more steps through strategic splits or dependency additions. Eight steps show project rhythm. Natural checkpoints emerge. Each step now represents focused work package. Eight steps provide technical leadership visibility into execution sequence. Descriptions hint at deliverables and artifacts.

<--- TRUST THE PROCESS ----->

@___13_sequential_steps___[THIRTEEN STEPS STAPPENPLAN]:
[FIBONACCI]13 = 05 STAPPENPLAN + 08 STAPPENPLAN
Fibonacci expansion: previous two step counts (5 + 8 = 13). Take the eight steps and add five more steps by splitting complex steps or revealing hidden dependencies. Thirteen steps show detailed execution path. Dependencies between steps become critical. Each step is actionable work item. Thirteen steps provide senior implementer visibility. Descriptions specify what gets built or configured.

<--- TRUST THE PROCESS ----->

@___21_sequential_steps___[TWENTY-ONE STEPS STAPPENPLAN]:
[FIBONACCI]21 = 08 STAPPENPLAN + 13 STAPPENPLAN
Fibonacci expansion: previous two step counts (8 + 13 = 21). Take the thirteen steps and add eight more steps by breaking down complex activities and exposing all major dependencies. Twenty-one steps show comprehensive implementation plan. Each step is discrete task. Dependencies form critical path. Twenty-one steps provide implementer-level granularity. Descriptions specify exact artifacts, commands, or configurations.

<--- TRUST THE PROCESS ----->

@___34_sequential_steps___[THIRTY-FOUR STEPS STAPPENPLAN]:
[FIBONACCI]34 = 13 STAPPENPLAN + 21 STAPPENPLAN
Fibonacci expansion: previous two step counts (13 + 21 = 34). Take the twenty-one steps and add thirteen more steps by splitting remaining complex steps into atomic actions. Thirty-four steps represent fully decomposed implementation plan. Each step is single-purpose action. No step requires further decomposition to execute. Thirty-four steps provide complete implementation visibility. This is final Fibonacci expansion before quality gates insertion.

<--- TRUST THE PROCESS ----->

@___36_sequential_steps___[THIRTY-SIX STEPS PLUS TWO INITIAL VALIDATIONS]:
[INIT]36 = 34 STAPPENPLAN + 02 CHECKLIST
Keep all thirty-four implementation steps. Add two validation checkpoint steps at early critical junctions: one after foundational setup, one after configuration complete. These first checkpoints validate project can proceed to complex implementation. Checkpoints define specific test files to create, list atomic tests to execute, reiterate one-test-one-validation principle, include TDD cycle guidance. Total: thirty-four STAPPENPLAN plus two validation equals thirty-six steps.

<--- TRUST THE PROCESS ----->

@___42_sequential_steps___[THIRTY-SIX STEPS PLUS SIX TOTAL VALIDATIONS]:
[EXPAND]42 = 36 STAPPENPLAN + 06 CHECKLIST
Keep all thirty-four implementation steps and two existing validations. Add two more implementation STAPPENPLAN and four more validation checkpoint steps at strategic boundaries: after CI pipeline, after integrity system, after release automation, after publishing system. Six checkpoints total now validate: foundation, configuration, CI, integrity, release, publishing. Each checkpoint validates cumulative work in its domain. Total: thirty-six STAPPENPLAN plus six validation equals forty-two steps.

<--- TRUST THE PROCESS ----->

@___48_sequential_steps___[THIRTY-SIX IMPLEMENTATION PLUS TWELVE VALIDATIONS]:
[EXPAND]48 = 36 STAPPENPLAN + 12 CHECKLIST
Keep all thirty-four implementation steps. Expand to thirty-six implementation steps by splitting two most critical steps. Split six checkpoints into twelve focused validation steps: each checkpoint becomes two validations testing core functionality and edge cases separately. Renumber everything sequentially as STEP_01 through STEP_48. Validation format matches previous phases. Total: thirty-six STAPPENPLAN plus twelve validation equals forty-eight steps.

<--- TRUST THE PROCESS ----->

@___52_sequential_steps___[FORTY-EIGHT STEPS PLUS FOUR GATEWAYS]:
[INIT]52 = 48 STEPS + 04 GATEWAY
Keep all forty-eight steps from previous phase. Insert four release gateway steps at major milestone boundaries: after foundation completion (GATEWAY_01), after validation infrastructure complete (GATEWAY_02), after core system functional (GATEWAY_03), after all validations pass (GATEWAY_04). Gateways aggregate multiple checkpoint results and add integration tests. Gateways block progression until prerequisites pass. Total: forty-eight steps plus four gateways equals fifty-two steps.

<--- TRUST THE PROCESS ----->

@___56_sequential_steps___[FORTY-EIGHT STEPS PLUS EIGHT GATEWAYS]:
[EXPAND]56 = 48 STEPS + 08 GATEWAY
Keep all forty-eight steps. Split four gateways into eight sub-gateways: automated verification gateway and manual review gateway for each milestone. Automated gateways run deterministic tests. Manual gateways require human sign-off on: documentation completeness, architecture review, security audit, performance benchmarks. Each manual gateway specifies exact review checklist. Total: forty-eight steps plus eight gateways equals fifty-six steps. Renumber gateways as GATEWAY_01 through GATEWAY_08.

-----

[END PROCESS DEFINITION]
